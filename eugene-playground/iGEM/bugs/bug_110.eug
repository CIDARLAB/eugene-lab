//Properties
Property Sequence(txt);
Property Name(txt);
Property Strength(num);
Property Direction(txt); 
Property Reliability(num);
Property SequenceLength(num);
Property RepressedBy(txt);
Property Represses(txt);
Property InducedBy(txt);
Property InducedByPlural(txt[]);
Property Induces(txt);

//Part Types
PartType SmallMolecule(Name, Sequence);
PartType RepressibleSmallMolecule(Name, RepressedBy);
PartType RepressiblePromoter(Name, Sequence, RepressedBy);
PartType InduciblePromoter(Name, Sequence, InducedBy);
PartType InduciblePromoterPlural(Name, Sequence, InducedByPlural);
PartType Inducer(Name, Sequence, Induces);
PartType ConstPromoter(Name, Sequence);
PartType Repressor(Name, Sequence, Represses);
PartType RBS(Name, Sequence);
PartType Terminator(Name, Sequence);
PartType Reporter(Name, Sequence);
PartType ReporterStrength(Name, Sequence, Strength);


//Part
SmallMolecule aTc("aTc", "dfsdfsdfsdf");
SmallMolecule AHL("AHL", "sdfsdfsdf");
RepressibleSmallMolecule tetRMolecule("tetR", "aTc");
ConstPromoter tetR("tetR", "acacacac");
RepressiblePromoter pTet("pTet", "agagag", "TetR");
RepressiblePromoter plac("pPlac", "gtgtgt", "lacI");
InduciblePromoterPlural PluxR("PluxR", "gcgcgc", ["AHL", "luxR"]);
RepressiblePromoter pLambda1 ("pLambda", "tgtgtg", "cI");
InduciblePromoter pLambda2 ("pLambda", "gtgtgt", "cI");
Inducer luxI("luxI", "catgcatg", "AHL");
Reporter gfp("gfp", "gatgatgat");
Repressor laci("LacI", "atgatgatg", "pLac");
Repressor CIRep("CI", "atatata", "pLamda1");
Repressor TetR("TetR", "gtgtgtgtgtg", "pTet");
Inducer CIInd("CI", "atatata", "pLambda2");
Reporter luxR("luxR", "tagtag");
Reporter lacI("lacI", "tgatga");

ReporterStrength CI("CI", "agagagagagag", 1);

//Devices
Device d1(SmallMolecule, Repressor, RepressiblePromoter, Inducer, SmallMolecule);
Device d2(SmallMolecule, InduciblePromoter);
Device hybrid(d1, d2, Reporter);
//Device d3(SmallMolecule, InduciblePromoter, X);
//Device loopDevice(

	
//Rules

Rule simpleRule(
	d1 STARTSWITH aTc);
//Rule simpleRule2(d2 ENDSWITH AHL);
Rule hybridRule(
	d1 STARTSWITH aTc 
	AND 
	d2 ENDSWITH AHL);
//Rule hybridRule(simpleRule AND simpleRule2);
Assert(
	ON hybrid: hybridRule);
Assert(
	ON hybrid: simpleRule);
Note(
	hybridRule);
Note(
	simpleRule);
//print 
Device[] deviceArray = product(hybrid, strict);
for (num i = 0; i < deviceArray.size(); i++) {
    println(deviceArray[i]);
}


//comments:

//-we don't know how to design devices in parallel
