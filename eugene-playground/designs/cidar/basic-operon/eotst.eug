Property seq(txt);
Property name(txt);
Property regulator(txt);
Property type(txt);
Property maxLow(num);
Property minHigh(num);
Property copyCount(num);


Part Promoter(name, type, regulator, minHigh, maxLow, seq);
Part miRNA(name, seq);
Part CDS(name, seq);
Part miRNASite(name, seq, regulator);


Promoter  pLac("pLac", "R", "LacI", 20, 0, "HAHA");
miRNA     m1("m1", "MAMA");
CDS       s1("s1", "SISI");
miRNASite ms1("m1", "MAMA", m1);
miRNASite ms2("m2", "PAPA", m1);


Device miRNA2x(miRNASite, miRNASite);
Device miRNA4x(miRNA2x, miRNA2x);
Device OutputmRNA(CDS, miRNA4x);

Device [] d = product(OutputmRNA);
Device dd;

function boolean allSame (Device d, Part p) {

    Part p1 = d[1];
    Rule r (p1 NEXTTO p);
    
    if (r) {
        return true;
    } else {
        return false;
    }
}


// rule test function
function boolean ruleTest (Device d, Part p, Part q) {
    Rule r1 (d CONTAINS p);
    Rule r2 (NOT (d CONTAINS q));
    Rule r3 (r1 AND r2);
    if (r3) {
        return true;
    } else {
        return false;
    }
}

boolean a,b;
Device[] functioningDevices;
for(num i=0; i<d.size(); i++) {
    a = ruleTest(d[i], ms1, ms2);
    if(a) {
        functioningDevices.add(d[i]);        
    }
    
    b = allSame(d[i], s1);
    if(b) {
        functioningDevices.add(d[i]);        
    }
    
}

print("*** FUNCTIONING DEVICES ***");
Device d1;
txt s;
for(num i=0;i<functioningDevices.size();i++) {
    d1 = functioningDevices[i];
    s = "";
    for(num j=0;j<d1.size();j++) {
        s = s + d1[1][1];
    }
    print(d1," -> ",s);
}
