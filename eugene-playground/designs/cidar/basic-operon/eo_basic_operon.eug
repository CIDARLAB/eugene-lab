
/* Nif HDKY Data Set 1 Parts */
/* ernst oberortner's version */

include "./case-study/basic-operon/design-space.h";

/*
 * Dehua's final device from first set, 
 * defined as an abstract device
 */ 
Device FirstDataSetDev (
    Promoter, 
        RBS, CDS, 
    Term, 
    Spacer, 
    Promoter,
        Spacer, RBS, CDS, 
        Spacer, RBS, CDS,
        Spacer, RBS, CDS,
    Term
);


/*
 * Devices needed to specify my ``basic'' rules.
 */
Device RC (
    RBS, CDS
);
Device RCTSP (
    RBS, CDS, Term, Spacer, Promoter
);
Device RCTP (
    RBS, CDS, Term, Promoter
);
Device SRC (
    Spacer, RBS, CDS
);
Device SRCTP (
    Spacer, RBS, CDS, Term, Promoter
);
Device RCT (
    RBS, CDS, Term
);
Device SRCT (
    Spacer, RBS, CDS, Term
);


/* function: checkBasicRules
 * Conjecture: this is ``equivalent'' to the regular expression: 
 * P (RC|RCTP|SRC|SRCTP)* (RCT|SRCT)
 */

function Device[] checkBasicRules(Device d) {
        
    Rule r1 (NOT (d STARTSWITH Promoter AND (d ENDSWITH RCT OR d ENDSWITH SRCT)));
    Rule r2 (d[0].Name != "ATCG");
    
    if(r1 AND r2) {
        return permute(d);
    }    
    
    Device[] lst;
    return lst;
    
    /**
    Rule r2 (d ENDSWITH RCT);
    Rule r3 (d ENDSWITH SRCT);
    Rule r4 (ON d: NOT RCT MORETHAN 1);
    Rule r5 (ON d: NOT SRCT MORETHAN 1);
    
    if (r1 AND (r2 OR r3) AND r4 AND r5) {
        Device[] lst = permute(d);
        return lst;
    }
    return false;
    **/
}

/* function: checkOperonRules
 * Example: Exactly three genes in an operon.
 * Two come from the rules, 
 * one more from the terminator device SRCT or RCT
 * which every device must contain.
 */
function boolean checkOperonRules(Device d) {
    Rule r1 (ON d: SRC MORETHAN 1);
    Rule r2 (ON d: RC MORETHAN 1);
    Rule r3 (ON d: NOT SRC MORETHAN 2);
    Rule r4 (ON d: NOT RC MORETHAN 2);
    if ((r1 OR r2) AND r3 AND r4) {
        return true;
    }
    return false;
}


/* function: printDevice
 * Prints device in Pigeon compatible form for autogeneration of pictures 
 */
function printDev(Device d) {
    num j = 0;
    for (num m=0; m<d.size(); m++) {
        if (d[m].Color > 0) {
            println(d[m].Type, " ", d[m].Name, " ", d[m].Color, " nl");
        } else {
            println(d[m].Type, " ", d[m].Name, " nl");
        }
    }
}


/*
 * Example device, which we can use to test the rules.
 * Abstract device whose components we permute --- order doesn't matter.
 * The rules ensure that only those permutations survive that satisfy the rules.
 */
Device NifDevice (
    Promoter, SRC, RCTSP, RCTSP, SRC, SRC, SRCT
);

boolean b, o;

/*
 * Generate all permutations of the abstract NifDevice device
 * and check which ones satisfy the rules (using the above declared functions)
 */

Device[] FirstDevices = checkBasicRules(NifDevice);
//println(FirstDevices);

/***
for (num i=0; i<FirstDevices.size(); i++) {

    // evaluate basic rules
    //b = checkBasicRules(FirstDevices[i]);
    
    // evaluate operon rules
    o = checkOperonRules(FirstDevices[i]);

    if (o) {
        // If an abstract device satisfies the rules, then
         // - fill it with concrete parts (product()) and
         // - print the concrete devices (printDev())
         ///
        Device d = product(FirstDevices[i]);
        for (num k=0; k<d.size(); k++) {
            printDev(d[k]);
        }
    }
}
 ****/

// NifDevice:
// without rules: 5040 (7!) permutations
// with rules: 486 devices
